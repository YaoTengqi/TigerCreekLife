# 虎溪生活

## 整体流程

 SpringBoot框架 -> Redis数据库 -> MySQL数据库



### 缓存

 	1.  **缓存更新策略**
      	1.  内存淘汰：利用redis的内部内存淘汰机制，无需新的维护成本
      	2.  超时剔除：设置一个TTL，超过这个TTL则将redis中的数据剔除
      	3.  主动更新：设计自己的更新逻辑，并以超时剔除为兜底，需要较高的维护成本
           - 采用Cache Aside Pattern：由缓存的调用者在更新数据库的同时更新缓存
             - 删除缓存：更新数据库时先删除缓存，当再次有查询来临时再更新缓存，防止写多读少的问题
             - 保证DB与CACHE的原子性：单体系统使用事务机制，分布式系统使用微服务
             - 先写数据库再删除缓存，保证线程安全(DB和Cache的双写一致性)
      	4.  适用情况：
           	1.  当业务的一致性要求较低时使用**内存淘汰**机制即可
           	2.  当业务的一致性要求较高时适用**主动更新**机制
 	2.  **缓存穿透**
      	1.  **出现原因：**客户端请求的数据在redis中以及database中都不存在造成一次空的数据库访问，如果被大量恶意穿透会导致数据库压力过大而宕机
      	2.  **解决办法：**
           	1.  缓存空数据并设置TTL，需要耗费额外的资源来维护此KV，实现较为简单。
           	2.  布隆过滤器：原理是**bitmap**，仍然有被穿透的风险，布隆过滤器中如果放行但数据库中不一定有，如果布隆过滤器不放心说明数据库中一定没有。实现较复杂但消耗资源更少。
 	3.  **缓存雪崩**
      	1.  **出现原因：**同一时间内redis的大量key失效或者redis直接宕机导致的大量请求发到数据库，带来巨大压力
      	2.  **解决办法：**
           	1.  设置随机TLL(避免在**同一时间内**大量key失效)
           	2.  上Redis集群提高可用性(避免宕机)
           	3.  给缓存业务添加限流降级操作
           	4.  添加多级缓存(nginx)，相当于添加了好几层保险
 	4.  **缓存击穿**
      	1.  **出现原因：**也叫热key问题，因为其产生的原因就是热点key失效，热点key具有被**高并发访问**且比较**难恢复**的问题，进而在比较长的一段时间导致大量请求打到数据库带来巨大压力的问题。
      	2.  **解决办法:**
           	1.  设置互斥锁(高一致性低可用性)
           	2.  设置逻辑过期时间(低一致性高可用性)

### 分布式锁

 	1. **需求原因：**当部署在多台JVM时会出现不同JVM进程并发访问业务的问题，会导致业务的內部锁失效，因此需要使用分布式锁
 	2. **模拟方法：**使用SpringBoot启动两个端口，并在nginx上修改配置文件反向代理到这两个端口上模拟分布式部署业务，并通过postman等进行接口测试
 	3. **需求实现：**通过redis来实现不同JVM进程间的锁，完成所有JVM共享同一把锁(**跨进程锁**)，因为redis可以被所有机器都看到，可以用来维护一把锁
     		1. ``tryLock``:获取互斥锁，将UUID拼接进程的id(可以区分不同JVM机器的不同线程)存入用户名的锁中
     		1. ``unlock``:释放锁的时候需要查看要释放的锁信息是否和以前相同，以防出现出现误删的问题。